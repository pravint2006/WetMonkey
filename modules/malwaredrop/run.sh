#!/usr/bin/env bash
# wetmonkey malwaredrop â€“ Interactive Malware Dropper Simulation & Detection Suite v2.0
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BASE_DIR="$SCRIPT_DIR/../../"
source "$BASE_DIR/core/utils.sh"

# Configuration
VERSION="2.0"
MAX_PORT=65535
MIN_PORT=1024

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

show_banner() {
    clear
    echo -e "${CYAN}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘    ğŸ’¾ WetMonkey Malware Dropper Simulatorâ•‘"
    echo "â•‘         Interactive Mode v2.0           â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

# Show usage information
show_help() {
    echo "WetMonkey Malware Dropper Simulation Module v${VERSION}"
    echo ""
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -h, --help              Show this help message"
    echo "  --mode <host|fetch>     Operation mode (legacy mode)"
    echo "  --file <path>           File to host (legacy mode)"
    echo "  --port <port>           Port to host on (legacy mode)"
    echo "  --url <url>             URL to fetch (legacy mode)"
    echo "  --simulate <mode>       Quick simulation (host|fetch)"
    echo ""
    echo "This module provides interactive malware dropper simulation and detection."
    echo "Supported features: Payload hosting, fetching simulation, detection analysis"
    echo ""
    echo "Example:"
    echo "  $0                      # Run in interactive mode"
    echo "  $0 -h                   # Show this help"
    echo "  $0 --simulate host      # Quick hosting simulation"
    echo "  $0 --mode host --file payload.exe --port 8080  # Legacy mode"
    echo ""
    echo "Note: This tool is for authorized security testing and research only!"
    echo "      Use responsibly and only on systems you own or have permission to test."
}

# Simple interactive input function
simple_input() {
    local prompt="$1"
    local default="${2:-}"
    local input

    if [ -n "$default" ]; then
        echo -ne "${BLUE}$prompt [${YELLOW}$default${BLUE}]: ${NC}" >&2
    else
        echo -ne "${BLUE}$prompt: ${NC}" >&2
    fi

    read -r input
    echo "${input:-$default}"
}

# Simple yes/no function
ask_yes_no() {
    local prompt="$1"
    local default="${2:-n}"
    local response

    while true; do
        if [ "$default" = "y" ]; then
            echo -ne "${BLUE}$prompt [Y/n]: ${NC}" >&2
        else
            echo -ne "${BLUE}$prompt [y/N]: ${NC}" >&2
        fi

        read -r response
        response="${response:-$default}"

        case "$response" in
            [Yy]|[Yy][Ee][Ss]) return 0 ;;
            [Nn]|[Nn][Oo]) return 1 ;;
            *) echo -e "${RED}Please answer yes or no.${NC}" >&2 ;;
        esac
    done
}

# Function to validate URL
validate_url() {
    local url="$1"
    if [[ $url =~ ^https?://[a-zA-Z0-9.-]+([:/][^[:space:]]*)?$ ]]; then
        return 0
    fi
    return 1
}

# Function to validate port
validate_port() {
    local port="$1"
    if [[ $port =~ ^[0-9]+$ ]] && [ $port -ge $MIN_PORT ] && [ $port -le $MAX_PORT ]; then
        return 0
    fi
    return 1
}

# Function to check if port is available
check_port_available() {
    local port="$1"
    if netstat -tuln 2>/dev/null | grep -q ":$port "; then
        return 1  # Port is in use
    fi
    return 0  # Port is available
}

# Function to create fake malware payloads for simulation
create_fake_payload() {
    local payload_type="$1"
    local filename="$2"
    local payload_dir="$SCRIPT_DIR/payloads"

    # Create payloads directory if it doesn't exist
    mkdir -p "$payload_dir"

    local full_path="$payload_dir/$filename"

    case "$payload_type" in
        "executable")
            # Create fake Windows executable
            echo -e "MZ\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xff\xff\x00\x00" > "$full_path"
            echo "# FAKE MALWARE PAYLOAD - FOR TESTING ONLY" >> "$full_path"
            echo "# This is a harmless test file created by WetMonkey" >> "$full_path"
            echo "# Creation time: $(date)" >> "$full_path"
            echo "# Payload type: Windows Executable Simulation" >> "$full_path"
            ;;
        "script")
            # Create fake PowerShell script
            cat > "$full_path" << 'EOF'
# FAKE MALWARE PAYLOAD - FOR TESTING ONLY
# This is a harmless test file created by WetMonkey
# Creation time: $(date)
# Payload type: PowerShell Script Simulation

Write-Host "This is a fake malware payload for testing purposes only"
Write-Host "Created by WetMonkey Malware Dropper Simulator"
Write-Host "No malicious actions will be performed"

# Simulate typical malware behavior patterns (harmless)
$env:COMPUTERNAME
$env:USERNAME
Get-Date
EOF
            ;;
        "document")
            # Create fake malicious document
            cat > "$full_path" << 'EOF'
FAKE MALWARE DOCUMENT - FOR TESTING ONLY

This document simulates a malicious file that might be dropped by malware.
It contains no actual malicious content and is safe for testing purposes.

Document Information:
- Created by: WetMonkey Malware Dropper Simulator
- Creation time: $(date)
- Payload type: Malicious Document Simulation
- File size: Small test file

This file would typically contain:
- Embedded macros (simulated)
- Exploit code (simulated)
- Social engineering content (simulated)

For educational and testing purposes only.
EOF
            ;;
        "archive")
            # Create fake malicious archive
            echo "# FAKE MALWARE ARCHIVE - FOR TESTING ONLY" > "$payload_dir/readme.txt"
            echo "# This archive simulates malware distribution" >> "$payload_dir/readme.txt"
            echo "# Created by WetMonkey at $(date)" >> "$payload_dir/readme.txt"

            if command -v zip >/dev/null 2>&1; then
                (cd "$payload_dir" && zip -q "$filename" readme.txt)
                rm "$payload_dir/readme.txt"
            else
                # Fallback if zip is not available
                echo "FAKE ZIP ARCHIVE HEADER" > "$full_path"
                echo "# This simulates a malicious archive file" >> "$full_path"
                echo "# Created by WetMonkey at $(date)" >> "$full_path"
            fi
            ;;
        "dropper")
            # Create fake dropper executable
            cat > "$full_path" << 'EOF'
#!/bin/bash
# FAKE MALWARE DROPPER - FOR TESTING ONLY
# This is a harmless test file created by WetMonkey
# Creation time: $(date)
# Payload type: Dropper Simulation

echo "This is a fake malware dropper for testing purposes only"
echo "Created by WetMonkey Malware Dropper Simulator"
echo "No malicious actions will be performed"

# Simulate dropper behavior (harmless)
echo "Simulating payload download..."
echo "Simulating persistence mechanism..."
echo "Simulating C2 communication..."
echo "Dropper simulation complete"
EOF
            chmod +x "$full_path"
            ;;
    esac

    echo "$full_path"
}

# Function to simulate malware hosting
simulate_malware_hosting() {
    local payload_type="$1"
    local port="$2"
    local duration="${3:-60}"

    echo -e "\n${GREEN}ğŸš€ Starting malware hosting simulation...${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${YELLOW}Payload Type: $payload_type${NC}"
    echo -e "${YELLOW}Port: $port${NC}"
    echo -e "${YELLOW}Duration: ${duration}s${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"

    # Create fake payload
    local filename
    case "$payload_type" in
        "executable") filename="malware.exe" ;;
        "script") filename="payload.ps1" ;;
        "document") filename="document.doc" ;;
        "archive") filename="files.zip" ;;
        "dropper") filename="dropper.sh" ;;
        *) filename="payload.bin" ;;
    esac

    echo -e "${CYAN}Creating fake $payload_type payload...${NC}"
    local payload_path
    payload_path=$(create_fake_payload "$payload_type" "$filename")

    if [ ! -f "$payload_path" ]; then
        echo -e "${RED}âŒ Failed to create payload${NC}"
        return 1
    fi

    local payload_size
    payload_size=$(stat -f%z "$payload_path" 2>/dev/null || stat -c%s "$payload_path" 2>/dev/null || echo "unknown")
    echo -e "${GREEN}âœ“ Payload created: $filename (${payload_size} bytes)${NC}"

    # Start HTTP server
    local payload_dir
    payload_dir=$(dirname "$payload_path")

    echo -e "\n${CYAN}Starting HTTP server on port $port...${NC}"

    # Try different HTTP server options
    local server_pid=""
    local server_cmd=""

    if command -v python3 >/dev/null 2>&1; then
        server_cmd="python3 -m http.server $port"
        echo -e "${BLUE}Using Python HTTP server${NC}"
    elif command -v python >/dev/null 2>&1; then
        server_cmd="python -m SimpleHTTPServer $port"
        echo -e "${BLUE}Using Python 2 HTTP server${NC}"
    elif command -v nc >/dev/null 2>&1; then
        # Fallback to netcat-based server (very basic)
        server_cmd="while true; do echo -e 'HTTP/1.1 200 OK\r\n\r\nFake payload served by WetMonkey' | nc -l -p $port; done"
        echo -e "${BLUE}Using netcat-based server${NC}"
    else
        echo -e "${RED}âŒ No suitable HTTP server found (python3, python, or nc required)${NC}"
        return 1
    fi

    # Start server in background
    (cd "$payload_dir" && eval "$server_cmd" >/dev/null 2>&1) &
    server_pid=$!

    # Wait a moment for server to start
    sleep 2

    # Check if server is running
    if ! kill -0 "$server_pid" 2>/dev/null; then
        echo -e "${RED}âŒ Failed to start HTTP server${NC}"
        return 1
    fi

    echo -e "${GREEN}âœ“ HTTP server started (PID: $server_pid)${NC}"
    echo -e "${YELLOW}Payload URL: http://$(hostname -I | awk '{print $1}' 2>/dev/null || echo 'localhost'):$port/$filename${NC}"
    echo -e "${YELLOW}Alternative URL: http://127.0.0.1:$port/$filename${NC}"

    # Monitor server for specified duration
    echo -e "\n${CYAN}Monitoring server activity...${NC}"
    local start_time=$(date +%s)
    local requests_served=0

    while [ $(($(date +%s) - start_time)) -lt $duration ]; do
        if ! kill -0 "$server_pid" 2>/dev/null; then
            echo -e "${RED}âš  Server process died unexpectedly${NC}"
            break
        fi

        # Simulate request monitoring (basic)
        if [ $(($(date +%s) - start_time)) -gt 0 ] && [ $((($(date +%s) - start_time) % 10)) -eq 0 ]; then
            echo -e "${BLUE}Server running... (${$(($(date +%s) - start_time))}s elapsed)${NC}"
        fi

        sleep 1
    done

    # Stop server
    echo -e "\n${CYAN}Stopping HTTP server...${NC}"
    kill "$server_pid" 2>/dev/null || true
    wait "$server_pid" 2>/dev/null || true

    # Cleanup
    if [ -f "$payload_path" ]; then
        rm -f "$payload_path"
        echo -e "${GREEN}âœ“ Payload file cleaned up${NC}"
    fi

    # Summary
    local end_time=$(date +%s)
    local total_time=$((end_time - start_time))

    echo -e "\n${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${GREEN}ğŸ“Š Hosting Simulation Summary${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}Payload type: $payload_type${NC}"
    echo -e "${CYAN}Filename: $filename${NC}"
    echo -e "${CYAN}Port: $port${NC}"
    echo -e "${CYAN}Duration: ${total_time}s${NC}"
    echo -e "${CYAN}Status: Completed successfully${NC}"

    echo -e "\n${YELLOW}Detection Indicators:${NC}"
    echo -e "â€¢ HTTP server on unusual port ($port)"
    echo -e "â€¢ Suspicious filename patterns ($filename)"
    echo -e "â€¢ Short-lived HTTP services"
    echo -e "â€¢ Executable file hosting"

    echo -e "\n${YELLOW}Recommended Monitoring:${NC}"
    echo -e "â€¢ Monitor for new HTTP services on non-standard ports"
    echo -e "â€¢ Track file downloads from suspicious sources"
    echo -e "â€¢ Analyze network traffic for malware distribution patterns"
    echo -e "â€¢ Monitor for executable file transfers"

    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

    return 0
}

# Function to simulate malware fetching
simulate_malware_fetching() {
    local url="$1"
    local fetch_method="${2:-curl}"
    local output_dir="${3:-/tmp}"

    echo -e "\n${GREEN}ğŸ”½ Starting malware fetching simulation...${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${YELLOW}Target URL: $url${NC}"
    echo -e "${YELLOW}Method: $fetch_method${NC}"
    echo -e "${YELLOW}Output directory: $output_dir${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"

    # Extract filename from URL
    local filename
    filename=$(basename "$url")
    if [ -z "$filename" ] || [ "$filename" = "/" ]; then
        filename="downloaded_payload"
    fi

    local output_path="$output_dir/$filename"

    # Test connectivity first
    echo -e "${CYAN}Testing connectivity to target...${NC}"
    if curl -s --connect-timeout 10 --max-time 15 -I "$url" >/dev/null 2>&1; then
        echo -e "${GREEN}âœ“ Target is reachable${NC}"
    else
        echo -e "${YELLOW}âš  Target may not be reachable (continuing anyway)${NC}"
    fi

    # Simulate different fetching methods
    local success=false
    local file_size=0
    local download_time=0
    local start_time=$(date +%s)

    echo -e "\n${CYAN}Attempting to fetch payload...${NC}"

    case "$fetch_method" in
        "curl")
            echo -e "${BLUE}Using curl for download${NC}"
            if curl -L --connect-timeout 30 --max-time 300 -o "$output_path" "$url" 2>/dev/null; then
                success=true
            fi
            ;;
        "wget")
            echo -e "${BLUE}Using wget for download${NC}"
            if command -v wget >/dev/null 2>&1; then
                if wget -q -T 30 -t 3 -O "$output_path" "$url" 2>/dev/null; then
                    success=true
                fi
            else
                echo -e "${YELLOW}âš  wget not available, falling back to curl${NC}"
                if curl -L --connect-timeout 30 --max-time 300 -o "$output_path" "$url" 2>/dev/null; then
                    success=true
                fi
            fi
            ;;
        "powershell")
            echo -e "${BLUE}Simulating PowerShell download${NC}"
            # Simulate PowerShell Invoke-WebRequest (using curl as backend)
            echo -e "${MAGENTA}PowerShell command: Invoke-WebRequest -Uri '$url' -OutFile '$output_path'${NC}"
            if curl -L --connect-timeout 30 --max-time 300 -o "$output_path" "$url" 2>/dev/null; then
                success=true
            fi
            ;;
        "python")
            echo -e "${BLUE}Simulating Python download${NC}"
            # Simulate Python urllib download (using curl as backend)
            echo -e "${MAGENTA}Python code: urllib.request.urlretrieve('$url', '$output_path')${NC}"
            if curl -L --connect-timeout 30 --max-time 300 -o "$output_path" "$url" 2>/dev/null; then
                success=true
            fi
            ;;
    esac

    local end_time=$(date +%s)
    download_time=$((end_time - start_time))

    # Analyze results
    if [ "$success" = true ] && [ -f "$output_path" ]; then
        file_size=$(stat -f%z "$output_path" 2>/dev/null || stat -c%s "$output_path" 2>/dev/null || echo "0")
        echo -e "${GREEN}âœ“ Download completed successfully${NC}"
        echo -e "${CYAN}File saved to: $output_path${NC}"
        echo -e "${CYAN}File size: $file_size bytes${NC}"
        echo -e "${CYAN}Download time: ${download_time}s${NC}"

        # Basic file analysis
        echo -e "\n${CYAN}Performing basic file analysis...${NC}"

        # File type detection
        local file_type="unknown"
        if command -v file >/dev/null 2>&1; then
            file_type=$(file -b "$output_path" 2>/dev/null || echo "unknown")
        else
            # Basic file type detection based on content
            if head -c 2 "$output_path" 2>/dev/null | grep -q "MZ"; then
                file_type="PE executable"
            elif head -c 4 "$output_path" 2>/dev/null | grep -q "PK"; then
                file_type="ZIP archive"
            elif head -c 4 "$output_path" 2>/dev/null | grep -q -E "<!|<html"; then
                file_type="HTML document"
            fi
        fi

        echo -e "${BLUE}File type: $file_type${NC}"

        # Hash calculation (if available)
        if command -v sha256sum >/dev/null 2>&1; then
            local file_hash
            file_hash=$(sha256sum "$output_path" | cut -d' ' -f1)
            echo -e "${BLUE}SHA256: $file_hash${NC}"
        elif command -v shasum >/dev/null 2>&1; then
            local file_hash
            file_hash=$(shasum -a 256 "$output_path" | cut -d' ' -f1)
            echo -e "${BLUE}SHA256: $file_hash${NC}"
        fi

        # Check for suspicious patterns
        echo -e "\n${CYAN}Checking for suspicious patterns...${NC}"
        local suspicious_indicators=()

        # Check for executable signatures
        if head -c 2 "$output_path" 2>/dev/null | grep -q "MZ"; then
            suspicious_indicators+=("PE executable signature detected")
        fi

        # Check for script patterns
        if grep -q -i "powershell\|cmd\|bash\|python" "$output_path" 2>/dev/null; then
            suspicious_indicators+=("Script execution patterns detected")
        fi

        # Check for network patterns
        if grep -q -i "http\|ftp\|tcp\|socket" "$output_path" 2>/dev/null; then
            suspicious_indicators+=("Network communication patterns detected")
        fi

        # Check for encoding patterns
        if grep -q -E "[A-Za-z0-9+/]{20,}={0,2}" "$output_path" 2>/dev/null; then
            suspicious_indicators+=("Base64 encoding patterns detected")
        fi

        if [ ${#suspicious_indicators[@]} -gt 0 ]; then
            echo -e "${YELLOW}âš  Suspicious indicators found:${NC}"
            for indicator in "${suspicious_indicators[@]}"; do
                echo -e "${YELLOW}  â€¢ $indicator${NC}"
            done
        else
            echo -e "${GREEN}âœ“ No obvious suspicious patterns detected${NC}"
        fi

    else
        echo -e "${RED}âŒ Download failed${NC}"
        file_size=0
    fi

    # Cleanup downloaded file
    if [ -f "$output_path" ]; then
        rm -f "$output_path"
        echo -e "\n${GREEN}âœ“ Downloaded file cleaned up${NC}"
    fi

    # Summary
    echo -e "\n${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${GREEN}ğŸ“Š Fetching Simulation Summary${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}Target URL: $url${NC}"
    echo -e "${CYAN}Method: $fetch_method${NC}"
    echo -e "${CYAN}Success: $([ "$success" = true ] && echo "Yes" || echo "No")${NC}"
    echo -e "${CYAN}File size: $file_size bytes${NC}"
    echo -e "${CYAN}Download time: ${download_time}s${NC}"

    if [ "$success" = true ]; then
        echo -e "\n${YELLOW}Detection Indicators:${NC}"
        echo -e "â€¢ Outbound HTTP/HTTPS connections to suspicious URLs"
        echo -e "â€¢ File downloads to temporary directories"
        echo -e "â€¢ Executable file downloads"
        echo -e "â€¢ Downloads using scripting tools (PowerShell, Python)"

        echo -e "\n${YELLOW}Recommended Monitoring:${NC}"
        echo -e "â€¢ Monitor outbound network connections"
        echo -e "â€¢ Track file downloads and creation in temp directories"
        echo -e "â€¢ Analyze downloaded file types and signatures"
        echo -e "â€¢ Monitor for script-based download activities"
    else
        echo -e "\n${YELLOW}Possible Reasons for Failure:${NC}"
        echo -e "â€¢ Target URL is unreachable"
        echo -e "â€¢ Network filtering is blocking the request"
        echo -e "â€¢ Target server is not responding"
        echo -e "â€¢ Invalid URL or file path"
    fi

    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

    return $([ "$success" = true ] && echo 0 || echo 1)
}

# Educational information function
show_educational_info() {
    clear
    echo -e "${CYAN}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘         ğŸ“š Malware Dropper Guide        â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}\n"

    echo -e "${GREEN}What are Malware Droppers?${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "Malware droppers are programs designed to install other malicious software"
    echo -e "on a target system. They serve as the initial infection vector and are"
    echo -e "responsible for downloading, installing, and executing additional payloads."
    echo -e "Droppers are often the first stage in multi-stage malware attacks.\n"

    echo -e "${GREEN}Common Dropper Techniques${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${YELLOW}1. HTTP/HTTPS Downloads${NC}"
    echo -e "   â€¢ Download payloads from web servers"
    echo -e "   â€¢ Use legitimate tools (curl, wget, PowerShell)"
    echo -e "   â€¢ Often use URL shorteners or compromised sites"
    echo -e "${YELLOW}2. FTP Downloads${NC}"
    echo -e "   â€¢ Download from FTP servers"
    echo -e "   â€¢ May use anonymous or compromised credentials"
    echo -e "   â€¢ Less common but still used"
    echo -e "${YELLOW}3. DNS-based Downloads${NC}"
    echo -e "   â€¢ Use DNS TXT records to store payload data"
    echo -e "   â€¢ Highly stealthy and hard to detect"
    echo -e "   â€¢ Bypass traditional network monitoring"
    echo -e "${YELLOW}4. Embedded Payloads${NC}"
    echo -e "   â€¢ Carry payloads within the dropper itself"
    echo -e "   â€¢ Extract and execute at runtime"
    echo -e "   â€¢ No network communication required\n"

    echo -e "${GREEN}Dropper Characteristics${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}File Types:${NC}"
    echo -e "â€¢ Executable files (.exe, .scr, .com)"
    echo -e "â€¢ Script files (.ps1, .bat, .vbs, .js)"
    echo -e "â€¢ Document files with macros (.doc, .xls, .pdf)"
    echo -e "â€¢ Archive files (.zip, .rar, .7z)"
    echo -e "${CYAN}Behavior Patterns:${NC}"
    echo -e "â€¢ Network connections to download additional payloads"
    echo -e "â€¢ File creation in temporary directories"
    echo -e "â€¢ Registry modifications for persistence"
    echo -e "â€¢ Process injection or hollowing"
    echo -e "${CYAN}Evasion Techniques:${NC}"
    echo -e "â€¢ Obfuscation and packing"
    echo -e "â€¢ Anti-analysis and sandbox detection"
    echo -e "â€¢ Living-off-the-land techniques"
    echo -e "â€¢ Time-based delays and triggers\n"

    echo -e "${GREEN}Detection Techniques${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}1. Network Monitoring:${NC}"
    echo -e "   â€¢ Monitor outbound HTTP/HTTPS connections"
    echo -e "   â€¢ Track downloads to suspicious domains"
    echo -e "   â€¢ Analyze DNS queries for anomalies"
    echo -e "${CYAN}2. File System Monitoring:${NC}"
    echo -e "   â€¢ Monitor file creation in temp directories"
    echo -e "   â€¢ Track executable file downloads"
    echo -e "   â€¢ Watch for suspicious file extensions"
    echo -e "${CYAN}3. Process Monitoring:${NC}"
    echo -e "   â€¢ Monitor for script execution (PowerShell, cmd)"
    echo -e "   â€¢ Track process creation chains"
    echo -e "   â€¢ Analyze command-line arguments"
    echo -e "${CYAN}4. Behavioral Analysis:${NC}"
    echo -e "   â€¢ Look for download-then-execute patterns"
    echo -e "   â€¢ Monitor for persistence mechanisms"
    echo -e "   â€¢ Analyze network communication patterns\n"

    echo -e "${GREEN}Prevention and Mitigation${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${GREEN}âœ“ Email Security:${NC}"
    echo -e "  â€¢ Filter executable attachments"
    echo -e "  â€¢ Scan for malicious macros"
    echo -e "  â€¢ Implement DMARC, SPF, and DKIM"
    echo -e "${GREEN}âœ“ Web Security:${NC}"
    echo -e "  â€¢ Block access to known malicious domains"
    echo -e "  â€¢ Implement web content filtering"
    echo -e "  â€¢ Use DNS filtering services"
    echo -e "${GREEN}âœ“ Endpoint Protection:${NC}"
    echo -e "  â€¢ Deploy EDR solutions"
    echo -e "  â€¢ Enable real-time file scanning"
    echo -e "  â€¢ Implement application whitelisting"
    echo -e "${GREEN}âœ“ Network Security:${NC}"
    echo -e "  â€¢ Monitor outbound connections"
    echo -e "  â€¢ Implement egress filtering"
    echo -e "  â€¢ Use network segmentation"
    echo -e "${GREEN}âœ“ User Education:${NC}"
    echo -e "  â€¢ Train users to recognize phishing"
    echo -e "  â€¢ Educate about safe download practices"
    echo -e "  â€¢ Implement security awareness programs\n"

    echo -e "${GREEN}Legal and Ethical Considerations${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${RED}âš  IMPORTANT:${NC} Only simulate droppers against systems you own or have permission"
    echo -e "${RED}âš  LEGAL:${NC} Unauthorized dropper simulation may violate computer crime laws"
    echo -e "${RED}âš  ETHICAL:${NC} Use simulations for defense improvement, not malicious purposes"
    echo -e "${RED}âš  PROFESSIONAL:${NC} Document findings and improve detection capabilities\n"
}

# Main interactive function
interactive_mode() {
    while true; do
        show_banner

        echo -e "${GREEN}Welcome to WetMonkey Malware Dropper Simulator!${NC}"
        echo -e "${YELLOW}This tool helps simulate and analyze malware dropper behavior for security testing.${NC}\n"
        echo -e "${RED}âš  WARNING: Only test against systems you own or have permission to test!${NC}\n"

        # Step 1: Operation type selection
        echo -e "${GREEN}Step 1: Operation Type${NC}"
        echo -e "Choose the type of dropper simulation:"
        echo -e "  ${YELLOW}1)${NC} Host Malware - Simulate hosting malicious payloads"
        echo -e "  ${YELLOW}2)${NC} Fetch Malware - Simulate downloading malicious payloads"
        echo -e "  ${YELLOW}3)${NC} Educational Information - Learn about malware droppers"

        local operation_type
        while true; do
            choice=$(simple_input "Select operation type (1-3)")
            case "$choice" in
                "1") operation_type="host"; break ;;
                "2") operation_type="fetch"; break ;;
                "3") operation_type="educational"; break ;;
                *) echo -e "${RED}Please select a number between 1-3${NC}" ;;
            esac
        done

        case "$operation_type" in
            "educational")
                # Show educational information
                show_educational_info
                echo -e "\n${YELLOW}Press Enter to continue...${NC}"
                read -r
                ;;

            "host")
                # Malware hosting simulation
                echo -e "\n${GREEN}Step 2: Payload Configuration${NC}"

                # Payload type selection
                echo -e "Choose the type of payload to host:"
                echo -e "  ${YELLOW}1)${NC} Executable - Fake Windows executable (.exe)"
                echo -e "  ${YELLOW}2)${NC} Script - Fake PowerShell script (.ps1)"
                echo -e "  ${YELLOW}3)${NC} Document - Fake malicious document (.doc)"
                echo -e "  ${YELLOW}4)${NC} Archive - Fake malicious archive (.zip)"
                echo -e "  ${YELLOW}5)${NC} Dropper - Fake dropper script (.sh)"

                local payload_type
                while true; do
                    choice=$(simple_input "Select payload type (1-5)")
                    case "$choice" in
                        "1") payload_type="executable"; break ;;
                        "2") payload_type="script"; break ;;
                        "3") payload_type="document"; break ;;
                        "4") payload_type="archive"; break ;;
                        "5") payload_type="dropper"; break ;;
                        *) echo -e "${RED}Please select a number between 1-5${NC}" ;;
                    esac
                done

                # Port configuration
                echo -e "\n${GREEN}Step 3: Server Configuration${NC}"

                local port
                while true; do
                    port=$(simple_input "Port to host on" "8080")
                    if validate_port "$port"; then
                        if check_port_available "$port"; then
                            break
                        else
                            echo -e "${RED}Port $port is already in use, please choose another${NC}"
                        fi
                    else
                        echo -e "${RED}Please enter a valid port (${MIN_PORT}-${MAX_PORT})${NC}"
                    fi
                done

                local duration
                while true; do
                    duration=$(simple_input "Hosting duration in seconds" "60")
                    if [[ $duration =~ ^[0-9]+$ ]] && [ $duration -ge 10 ] && [ $duration -le 3600 ]; then
                        break
                    else
                        echo -e "${RED}Please enter a valid duration (10-3600 seconds)${NC}"
                    fi
                done

                # Confirmation and execution
                echo -e "\n${GREEN}Step 4: Hosting Summary${NC}"
                echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
                echo -e "${CYAN}Payload type: $payload_type${NC}"
                echo -e "${CYAN}Port: $port${NC}"
                echo -e "${CYAN}Duration: ${duration}s (~$((duration / 60))min)${NC}"
                echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

                echo -e "\n${RED}âš  WARNING: This will host a fake malware payload!${NC}"
                echo -e "${RED}âš  Only proceed if you have authorization to run this test!${NC}"

                if ask_yes_no "Start hosting simulation?" "n"; then
                    echo -e "\n${CYAN}Starting hosting simulation...${NC}"

                    # Log start
                    log_json "malwaredrop_host_start" "payload_type=$payload_type port=$port duration=$duration" 2>/dev/null || true

                    # Perform hosting simulation
                    simulate_malware_hosting "$payload_type" "$port" "$duration"

                    # Log end
                    log_json "malwaredrop_host_end" "payload_type=$payload_type port=$port" 2>/dev/null || true
                else
                    echo -e "${YELLOW}Hosting simulation cancelled.${NC}"
                fi
                ;;

            "fetch")
                # Malware fetching simulation
                echo -e "\n${GREEN}Step 2: Target Configuration${NC}"

                local url
                while true; do
                    url=$(simple_input "Target URL to fetch from")
                    if [ -z "$url" ]; then
                        echo -e "${RED}URL is required!${NC}"
                        continue
                    fi

                    if validate_url "$url"; then
                        break
                    else
                        echo -e "${RED}Please enter a valid URL (http:// or https://)${NC}"
                    fi
                done

                # Method selection
                echo -e "\n${GREEN}Step 3: Fetch Method${NC}"
                echo -e "Choose the fetching method to simulate:"
                echo -e "  ${YELLOW}1)${NC} curl - Command-line HTTP client"
                echo -e "  ${YELLOW}2)${NC} wget - Web file downloader"
                echo -e "  ${YELLOW}3)${NC} PowerShell - Windows PowerShell download"
                echo -e "  ${YELLOW}4)${NC} Python - Python urllib download"

                local fetch_method
                while true; do
                    choice=$(simple_input "Select fetch method (1-4)")
                    case "$choice" in
                        "1") fetch_method="curl"; break ;;
                        "2") fetch_method="wget"; break ;;
                        "3") fetch_method="powershell"; break ;;
                        "4") fetch_method="python"; break ;;
                        *) echo -e "${RED}Please select a number between 1-4${NC}" ;;
                    esac
                done

                # Confirmation and execution
                echo -e "\n${GREEN}Step 4: Fetching Summary${NC}"
                echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
                echo -e "${CYAN}Target URL: $url${NC}"
                echo -e "${CYAN}Method: $fetch_method${NC}"
                echo -e "${CYAN}Output: /tmp/ (temporary, will be cleaned up)${NC}"
                echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

                echo -e "\n${RED}âš  WARNING: This will attempt to download from the target URL!${NC}"
                echo -e "${RED}âš  Only proceed if you have authorization to test this target!${NC}"

                if ask_yes_no "Start fetching simulation?" "n"; then
                    echo -e "\n${CYAN}Starting fetching simulation...${NC}"

                    # Log start
                    log_json "malwaredrop_fetch_start" "url=$url method=$fetch_method" 2>/dev/null || true

                    # Perform fetching simulation
                    simulate_malware_fetching "$url" "$fetch_method" "/tmp"
                    local fetch_result=$?

                    # Log end
                    log_json "malwaredrop_fetch_end" "url=$url method=$fetch_method success=$([ $fetch_result -eq 0 ] && echo true || echo false)" 2>/dev/null || true
                else
                    echo -e "${YELLOW}Fetching simulation cancelled.${NC}"
                fi
                ;;
        esac

        echo -e "\n${YELLOW}Press Enter to continue...${NC}"
        read -r

        if ! ask_yes_no "Perform another simulation?" "y"; then
            break
        fi
    done
}

# Legacy mode functions
legacy_host_mode() {
    local file="$1"
    local port="$2"

    echo -e "${YELLOW}Running in legacy host mode...${NC}"
    echo -e "${RED}âš  WARNING: Only host files you own or have permission to serve!${NC}\n"

    # Validate parameters
    if [ ! -f "$file" ]; then
        echo -e "${RED}Error: File '$file' does not exist${NC}" >&2
        exit 1
    fi

    if ! validate_port "$port"; then
        echo -e "${RED}Error: Invalid port (${MIN_PORT}-${MAX_PORT})${NC}" >&2
        exit 1
    fi

    if ! check_port_available "$port"; then
        echo -e "${RED}Error: Port $port is already in use${NC}" >&2
        exit 1
    fi

    # Log start
    log_json "malwaredrop_host_start" "file=$file port=$port mode=legacy" 2>/dev/null || true

    # Start HTTP server
    local file_dir
    file_dir=$(dirname "$file")
    local filename
    filename=$(basename "$file")

    echo -e "${CYAN}Starting HTTP server for file: $filename${NC}"
    echo -e "${CYAN}Port: $port${NC}"
    echo -e "${CYAN}Directory: $file_dir${NC}"

    # Try different HTTP server options
    if command -v python3 >/dev/null 2>&1; then
        echo -e "${BLUE}Using Python 3 HTTP server${NC}"
        echo -e "${YELLOW}File URL: http://$(hostname -I | awk '{print $1}' 2>/dev/null || echo 'localhost'):$port/$filename${NC}"
        echo -e "${YELLOW}Press Ctrl+C to stop the server${NC}\n"
        (cd "$file_dir" && python3 -m http.server "$port")
    elif command -v python >/dev/null 2>&1; then
        echo -e "${BLUE}Using Python 2 HTTP server${NC}"
        echo -e "${YELLOW}File URL: http://$(hostname -I | awk '{print $1}' 2>/dev/null || echo 'localhost'):$port/$filename${NC}"
        echo -e "${YELLOW}Press Ctrl+C to stop the server${NC}\n"
        (cd "$file_dir" && python -m SimpleHTTPServer "$port")
    else
        echo -e "${RED}âŒ No suitable HTTP server found (python3 or python required)${NC}"
        exit 1
    fi

    # Log end
    log_json "malwaredrop_host_end" "file=$file port=$port" 2>/dev/null || true
}

legacy_fetch_mode() {
    local url="$1"

    echo -e "${YELLOW}Running in legacy fetch mode...${NC}"
    echo -e "${RED}âš  WARNING: Only fetch from URLs you own or have permission to test!${NC}\n"

    # Validate URL
    if ! validate_url "$url"; then
        echo -e "${RED}Error: Invalid URL format${NC}" >&2
        exit 1
    fi

    # Log start
    log_json "malwaredrop_fetch_start" "url=$url mode=legacy" 2>/dev/null || true

    # Perform fetch
    local filename
    filename=$(basename "$url")
    if [ -z "$filename" ] || [ "$filename" = "/" ]; then
        filename="downloaded_file"
    fi

    local output_path="/tmp/$filename"

    echo -e "${CYAN}Fetching from: $url${NC}"
    echo -e "${CYAN}Output file: $output_path${NC}"

    # Try wget first, then curl
    local success=false
    if command -v wget >/dev/null 2>&1; then
        echo -e "${BLUE}Using wget${NC}"
        if wget -q -T 30 -t 3 -O "$output_path" "$url"; then
            success=true
        fi
    fi

    if [ "$success" = false ] && command -v curl >/dev/null 2>&1; then
        echo -e "${BLUE}Using curl${NC}"
        if curl -L --connect-timeout 30 --max-time 300 -o "$output_path" "$url"; then
            success=true
        fi
    fi

    if [ "$success" = true ] && [ -f "$output_path" ]; then
        local file_size
        file_size=$(stat -f%z "$output_path" 2>/dev/null || stat -c%s "$output_path" 2>/dev/null || echo "0")
        echo -e "${GREEN}âœ“ Download completed successfully${NC}"
        echo -e "${CYAN}File size: $file_size bytes${NC}"
        echo -e "${CYAN}File saved to: $output_path${NC}"
    else
        echo -e "${RED}âŒ Download failed${NC}"
        exit 1
    fi

    # Log end
    log_json "malwaredrop_fetch_end" "url=$url success=$success" 2>/dev/null || true
}

# Main function
main() {
    local mode=""
    local file=""
    local port="8080"
    local url=""
    local simulate_mode=""

    # Parse command line arguments
    if [[ $# -gt 0 ]]; then
        while [[ $# -gt 0 ]]; do
            case "$1" in
                -h|--help)
                    show_help
                    exit 0
                    ;;
                --mode)
                    if [ -z "${2:-}" ]; then
                        echo -e "${RED}Error: --mode requires a value (host|fetch)${NC}" >&2
                        exit 1
                    fi
                    mode="$2"
                    shift 2
                    ;;
                --file)
                    if [ -z "${2:-}" ]; then
                        echo -e "${RED}Error: --file requires a file path${NC}" >&2
                        exit 1
                    fi
                    file="$2"
                    shift 2
                    ;;
                --port)
                    if [ -z "${2:-}" ]; then
                        echo -e "${RED}Error: --port requires a port number${NC}" >&2
                        exit 1
                    fi
                    port="$2"
                    shift 2
                    ;;
                --url)
                    if [ -z "${2:-}" ]; then
                        echo -e "${RED}Error: --url requires a URL${NC}" >&2
                        exit 1
                    fi
                    url="$2"
                    shift 2
                    ;;
                --simulate)
                    if [ -z "${2:-}" ]; then
                        echo -e "${RED}Error: --simulate requires a mode (host|fetch)${NC}" >&2
                        exit 1
                    fi
                    simulate_mode="$2"
                    shift 2
                    ;;
                *)
                    echo -e "${RED}Unknown option: $1${NC}" >&2
                    echo "Use -h for help." >&2
                    exit 1
                    ;;
            esac
        done

        # Handle quick simulation mode
        if [ -n "$simulate_mode" ]; then
            case "$simulate_mode" in
                "host")
                    echo -e "${GREEN}Quick Hosting Simulation${NC}"

                    # Log start
                    log_json "malwaredrop_host_start" "mode=quick_simulation" 2>/dev/null || true

                    # Perform quick hosting simulation
                    simulate_malware_hosting "executable" "8080" "30"

                    # Log end
                    log_json "malwaredrop_host_end" "mode=quick_simulation" 2>/dev/null || true
                    ;;
                "fetch")
                    echo -e "${GREEN}Quick Fetching Simulation${NC}"
                    echo -e "${YELLOW}Note: This requires a target URL to be effective${NC}"
                    echo -e "${YELLOW}Use interactive mode for full fetching simulation${NC}"
                    ;;
                *)
                    echo -e "${RED}Error: Invalid simulation mode (host|fetch)${NC}" >&2
                    exit 1
                    ;;
            esac
            exit 0
        fi

        # Handle legacy mode
        if [ -n "$mode" ]; then
            case "$mode" in
                "host")
                    if [ -z "$file" ]; then
                        echo -e "${RED}Error: --file is required for host mode${NC}" >&2
                        exit 1
                    fi
                    legacy_host_mode "$file" "$port"
                    ;;
                "fetch")
                    if [ -z "$url" ]; then
                        echo -e "${RED}Error: --url is required for fetch mode${NC}" >&2
                        exit 1
                    fi
                    legacy_fetch_mode "$url"
                    ;;
                *)
                    echo -e "${RED}Error: Invalid mode (host|fetch)${NC}" >&2
                    exit 1
                    ;;
            esac
            exit $?
        fi

        # If we get here, invalid combination of arguments
        echo -e "${RED}Error: Invalid argument combination${NC}" >&2
        echo "Use -h for help or run without arguments for interactive mode." >&2
        exit 1
    fi

    # Check dependencies for interactive mode
    missing_deps=()
    if ! command -v curl >/dev/null 2>&1; then
        missing_deps+=("curl")
    fi

    if [ ${#missing_deps[@]} -gt 0 ]; then
        echo -e "${YELLOW}Warning: Some tools are missing: ${missing_deps[*]}${NC}"
        echo -e "${YELLOW}Some features may have reduced functionality.${NC}\n"
    fi

    # Start interactive mode
    interactive_mode
}

# Run the main function with all arguments
main "$@"
