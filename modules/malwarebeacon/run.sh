#!/usr/bin/env bash
# wetmonkey malwarebeacon â€“ Interactive Malware Beacon Simulation & Detection Suite v2.0
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BASE_DIR="$SCRIPT_DIR/../../"
source "$BASE_DIR/core/utils.sh"

# Configuration
VERSION="2.0"
MAX_BEACONS=1000
MAX_INTERVAL=3600  # 1 hour max

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

show_banner() {
    clear
    echo -e "${CYAN}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘    ğŸ“¡ WetMonkey Malware Beacon Simulator â•‘"
    echo "â•‘         Interactive Mode v2.0           â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

# Show usage information
show_help() {
    echo "WetMonkey Malware Beacon Simulation Module v${VERSION}"
    echo ""
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -h, --help              Show this help message"
    echo "  -u, --url <url>         Target URL (legacy mode)"
    echo "  --interval <seconds>    Beacon interval (legacy mode)"
    echo "  --count <number>        Number of beacons (legacy mode)"
    echo "  --simulate <url>        Quick beacon simulation"
    echo ""
    echo "This module provides interactive malware beacon simulation and detection."
    echo "Supported features: Beacon patterns, C2 simulation, detection analysis"
    echo ""
    echo "Example:"
    echo "  $0                      # Run in interactive mode"
    echo "  $0 -h                   # Show this help"
    echo "  $0 --simulate http://c2.example.com  # Quick beacon test"
    echo "  $0 -u http://c2.example.com --interval 60 --count 5  # Legacy mode"
    echo ""
    echo "Note: This tool is for authorized security testing and research only!"
    echo "      Use responsibly and only on systems you own or have permission to test."
}

# Simple interactive input function
simple_input() {
    local prompt="$1"
    local default="${2:-}"
    local input

    if [ -n "$default" ]; then
        echo -ne "${BLUE}$prompt [${YELLOW}$default${BLUE}]: ${NC}" >&2
    else
        echo -ne "${BLUE}$prompt: ${NC}" >&2
    fi

    read -r input
    echo "${input:-$default}"
}

# Simple yes/no function
ask_yes_no() {
    local prompt="$1"
    local default="${2:-n}"
    local response

    while true; do
        if [ "$default" = "y" ]; then
            echo -ne "${BLUE}$prompt [Y/n]: ${NC}" >&2
        else
            echo -ne "${BLUE}$prompt [y/N]: ${NC}" >&2
        fi

        read -r response
        response="${response:-$default}"

        case "$response" in
            [Yy]|[Yy][Ee][Ss]) return 0 ;;
            [Nn]|[Nn][Oo]) return 1 ;;
            *) echo -e "${RED}Please answer yes or no.${NC}" >&2 ;;
        esac
    done
}

# Function to validate URL
validate_url() {
    local url="$1"
    if [[ $url =~ ^https?://[a-zA-Z0-9.-]+([:/][^[:space:]]*)?$ ]]; then
        return 0
    fi
    return 1
}

# Function to check if URL is reachable
check_url_reachable() {
    local url="$1"
    echo -e "${YELLOW}Testing connectivity to $url...${NC}" >&2

    if curl -s --connect-timeout 10 --max-time 15 -I "$url" >/dev/null 2>&1; then
        echo -e "${GREEN}âœ“ Target is reachable${NC}" >&2
        return 0
    else
        echo -e "${YELLOW}âš  Target may not be reachable (continuing anyway)${NC}" >&2
        return 0  # Don't fail, just warn
    fi
}

# Function to generate realistic malware beacon patterns
generate_beacon_data() {
    local pattern="$1"
    local beacon_id="$2"

    case "$pattern" in
        "basic")
            # Basic HTTP GET beacon
            echo "GET /?id=${beacon_id}&ts=$(date +%s) HTTP/1.1"
            ;;
        "encoded")
            # Base64 encoded beacon data
            local data="id=${beacon_id}&hostname=$(hostname)&ts=$(date +%s)"
            local encoded=$(echo -n "$data" | base64 | tr -d '\n')
            echo "GET /?data=${encoded} HTTP/1.1"
            ;;
        "json")
            # JSON payload beacon
            local json="{\"id\":\"${beacon_id}\",\"hostname\":\"$(hostname)\",\"timestamp\":$(date +%s),\"status\":\"active\"}"
            echo "POST / HTTP/1.1"
            echo "Content-Type: application/json"
            echo "Content-Length: ${#json}"
            echo ""
            echo "$json"
            ;;
        "steganography")
            # Hidden in fake image request
            echo "GET /images/logo_${beacon_id}_$(date +%s).png HTTP/1.1"
            ;;
        "dns")
            # DNS-based beacon (simulated)
            echo "DNS Query: ${beacon_id}.$(date +%s).malware.example.com"
            ;;
    esac
}

# Function to simulate malware beacon traffic
simulate_beacon_traffic() {
    local url="$1"
    local pattern="$2"
    local interval="$3"
    local count="$4"
    local jitter="${5:-0}"

    echo -e "\n${GREEN}ğŸš€ Starting malware beacon simulation...${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${YELLOW}Target: $url${NC}"
    echo -e "${YELLOW}Pattern: $pattern${NC}"
    echo -e "${YELLOW}Interval: ${interval}s (Â±${jitter}s jitter)${NC}"
    echo -e "${YELLOW}Count: $count beacons${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"

    local beacon_id="beacon_$(date +%s)_$$"
    local successful_beacons=0
    local failed_beacons=0
    local start_time=$(date +%s)

    for ((i=1; i<=count; i++)); do
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))

        echo -e "${CYAN}Beacon $i/$count (${elapsed}s elapsed)${NC}"

        # Generate beacon data based on pattern
        local beacon_data
        beacon_data=$(generate_beacon_data "$pattern" "${beacon_id}_${i}")

        # Show beacon data (first few lines only)
        echo -e "${BLUE}Beacon data:${NC}"
        echo "$beacon_data" | head -3 | sed 's/^/  /'

        # Send beacon
        local response_code
        case "$pattern" in
            "json")
                # POST request for JSON
                local json_data=$(echo "$beacon_data" | tail -1)
                response_code=$(curl -s -o /dev/null -w "%{http_code}" \
                    -X POST \
                    -H "Content-Type: application/json" \
                    -d "$json_data" \
                    --connect-timeout 10 --max-time 15 \
                    "$url" 2>/dev/null || echo "000")
                ;;
            "dns")
                # Simulate DNS beacon (just show the query)
                echo -e "${MAGENTA}  DNS beacon simulated (no actual query sent)${NC}"
                response_code="200"  # Simulate success
                ;;
            *)
                # GET request for other patterns
                local query_params=$(echo "$beacon_data" | grep -o '/?.*' | head -1)
                response_code=$(curl -s -o /dev/null -w "%{http_code}" \
                    --connect-timeout 10 --max-time 15 \
                    "${url}${query_params}" 2>/dev/null || echo "000")
                ;;
        esac

        # Analyze response
        if [[ $response_code =~ ^[2-3][0-9][0-9]$ ]]; then
            echo -e "${GREEN}  âœ“ Beacon sent successfully (HTTP $response_code)${NC}"
            ((successful_beacons++))
        else
            echo -e "${RED}  âœ— Beacon failed (HTTP $response_code)${NC}"
            ((failed_beacons++))
        fi

        # Sleep with jitter if not the last beacon
        if [ $i -lt $count ]; then
            local sleep_time=$interval
            if [ $jitter -gt 0 ]; then
                local jitter_amount=$((RANDOM % (jitter * 2) - jitter))
                sleep_time=$((interval + jitter_amount))
                if [ $sleep_time -lt 1 ]; then
                    sleep_time=1
                fi
            fi

            echo -e "${YELLOW}  Waiting ${sleep_time}s until next beacon...${NC}"
            sleep "$sleep_time"
        fi

        echo ""
    done

    # Summary
    local end_time=$(date +%s)
    local total_time=$((end_time - start_time))

    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${GREEN}ğŸ“Š Beacon Simulation Summary${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}Target: $url${NC}"
    echo -e "${CYAN}Pattern: $pattern${NC}"
    echo -e "${CYAN}Total beacons: $count${NC}"
    echo -e "${CYAN}Successful: $successful_beacons${NC}"
    echo -e "${CYAN}Failed: $failed_beacons${NC}"
    echo -e "${CYAN}Success rate: $(( (successful_beacons * 100) / count ))%${NC}"
    echo -e "${CYAN}Total time: ${total_time}s${NC}"

    if [ $successful_beacons -gt 0 ]; then
        echo -e "${GREEN}âœ… BEACON SIMULATION COMPLETED${NC}"
        echo -e "${YELLOW}Detection Recommendations:${NC}"
        echo -e "â€¢ Monitor for regular HTTP requests with similar patterns"
        echo -e "â€¢ Look for base64 encoded data in URL parameters"
        echo -e "â€¢ Check for unusual DNS queries with encoded data"
        echo -e "â€¢ Analyze request timing patterns and intervals"
        echo -e "â€¢ Monitor for requests to suspicious domains"
    else
        echo -e "${RED}âŒ ALL BEACONS FAILED${NC}"
        echo -e "${YELLOW}Possible reasons:${NC}"
        echo -e "â€¢ Target server is unreachable"
        echo -e "â€¢ Network filtering is blocking requests"
        echo -e "â€¢ Target server is rejecting requests"
    fi

    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

    return 0
}

# Function to analyze beacon patterns for detection
analyze_beacon_patterns() {
    local pattern="$1"
    local interval="$2"
    local count="$3"

    echo -e "\n${GREEN}ğŸ” Analyzing beacon pattern for detection...${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${YELLOW}Pattern: $pattern${NC}"
    echo -e "${YELLOW}Interval: ${interval}s${NC}"
    echo -e "${YELLOW}Count: $count${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"

    local detection_score=0
    local indicators=()

    # Analyze pattern characteristics
    case "$pattern" in
        "basic")
            echo -e "${CYAN}Basic HTTP GET Pattern Analysis:${NC}"
            echo -e "â€¢ Simple GET requests with timestamp parameters"
            echo -e "â€¢ Easy to detect with basic HTTP monitoring"
            echo -e "â€¢ Low stealth, high detectability"
            detection_score=2
            indicators+=("Regular GET requests with timestamp parameters")
            ;;
        "encoded")
            echo -e "${CYAN}Base64 Encoded Pattern Analysis:${NC}"
            echo -e "â€¢ Data encoded in base64 to avoid simple detection"
            echo -e "â€¢ Requires content inspection for detection"
            echo -e "â€¢ Medium stealth, medium detectability"
            detection_score=4
            indicators+=("Base64 encoded data in URL parameters")
            indicators+=("Regular pattern of encoded requests")
            ;;
        "json")
            echo -e "${CYAN}JSON POST Pattern Analysis:${NC}"
            echo -e "â€¢ Uses POST requests with JSON payloads"
            echo -e "â€¢ Mimics legitimate API traffic"
            echo -e "â€¢ Medium-high stealth, requires deep inspection"
            detection_score=6
            indicators+=("Regular POST requests with JSON payloads")
            indicators+=("Consistent JSON structure across requests")
            ;;
        "steganography")
            echo -e "${CYAN}Steganographic Pattern Analysis:${NC}"
            echo -e "â€¢ Hidden in fake image requests"
            echo -e "â€¢ High stealth, difficult to detect without analysis"
            echo -e "â€¢ Requires behavioral analysis for detection"
            detection_score=8
            indicators+=("Regular requests for non-existent images")
            indicators+=("Suspicious image filename patterns")
            ;;
        "dns")
            echo -e "${CYAN}DNS Beacon Pattern Analysis:${NC}"
            echo -e "â€¢ Uses DNS queries for C2 communication"
            echo -e "â€¢ Very high stealth, bypasses HTTP monitoring"
            echo -e "â€¢ Requires DNS monitoring and analysis"
            detection_score=9
            indicators+=("Regular DNS queries with encoded data")
            indicators+=("Suspicious subdomain patterns")
            ;;
    esac

    # Analyze timing characteristics
    echo -e "\n${CYAN}Timing Pattern Analysis:${NC}"
    if [ $interval -lt 60 ]; then
        echo -e "${RED}â€¢ Very frequent beacons (<60s) - highly suspicious${NC}"
        ((detection_score += 2))
        indicators+=("Very frequent beacon intervals")
    elif [ $interval -lt 300 ]; then
        echo -e "${YELLOW}â€¢ Frequent beacons (1-5min) - moderately suspicious${NC}"
        ((detection_score += 1))
        indicators+=("Frequent beacon intervals")
    elif [ $interval -lt 3600 ]; then
        echo -e "${BLUE}â€¢ Regular beacons (5-60min) - normal for malware${NC}"
        indicators+=("Regular beacon intervals")
    else
        echo -e "${GREEN}â€¢ Infrequent beacons (>1hr) - harder to detect${NC}"
        ((detection_score -= 1))
    fi

    # Analyze volume
    echo -e "\n${CYAN}Volume Analysis:${NC}"
    if [ $count -gt 100 ]; then
        echo -e "${RED}â€¢ High volume (>100 beacons) - creates clear pattern${NC}"
        ((detection_score += 2))
        indicators+=("High volume of beacon requests")
    elif [ $count -gt 20 ]; then
        echo -e "${YELLOW}â€¢ Medium volume (20-100 beacons) - detectable pattern${NC}"
        ((detection_score += 1))
        indicators+=("Medium volume of beacon requests")
    else
        echo -e "${BLUE}â€¢ Low volume (<20 beacons) - harder to establish pattern${NC}"
    fi

    # Detection recommendations
    echo -e "\n${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${GREEN}ğŸ›¡ï¸ Detection Analysis Results${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}Detection Difficulty Score: $detection_score/15${NC}"

    if [ $detection_score -ge 10 ]; then
        echo -e "${RED}ğŸš¨ HIGH DETECTABILITY: Easy to detect with basic monitoring${NC}"
    elif [ $detection_score -ge 6 ]; then
        echo -e "${YELLOW}âš  MEDIUM DETECTABILITY: Requires content inspection${NC}"
    elif [ $detection_score -ge 3 ]; then
        echo -e "${BLUE}â„¹ LOW DETECTABILITY: Requires behavioral analysis${NC}"
    else
        echo -e "${GREEN}âœ“ VERY LOW DETECTABILITY: Advanced techniques needed${NC}"
    fi

    if [ ${#indicators[@]} -gt 0 ]; then
        echo -e "\n${YELLOW}Detection Indicators:${NC}"
        for indicator in "${indicators[@]}"; do
            echo -e "  â€¢ $indicator"
        done
    fi

    echo -e "\n${YELLOW}Recommended Detection Methods:${NC}"
    case "$pattern" in
        "basic")
            echo -e "â€¢ HTTP request monitoring and logging"
            echo -e "â€¢ URL parameter analysis"
            echo -e "â€¢ Request frequency analysis"
            ;;
        "encoded")
            echo -e "â€¢ Deep packet inspection (DPI)"
            echo -e "â€¢ Base64 pattern detection in URLs"
            echo -e "â€¢ Content analysis and decoding"
            ;;
        "json")
            echo -e "â€¢ HTTP POST monitoring"
            echo -e "â€¢ JSON payload analysis"
            echo -e "â€¢ API traffic behavioral analysis"
            ;;
        "steganography")
            echo -e "â€¢ HTTP request behavioral analysis"
            echo -e "â€¢ File request pattern monitoring"
            echo -e "â€¢ Response code analysis (404s for fake images)"
            ;;
        "dns")
            echo -e "â€¢ DNS query monitoring and logging"
            echo -e "â€¢ Subdomain pattern analysis"
            echo -e "â€¢ DNS tunnel detection tools"
            ;;
    esac

    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

    return 0
}

# Educational information function
show_educational_info() {
    clear
    echo -e "${CYAN}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘         ğŸ“š Malware Beacon Guide         â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}\n"

    echo -e "${GREEN}What are Malware Beacons?${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "Malware beacons are periodic communications from infected systems to"
    echo -e "command and control (C2) servers. They serve multiple purposes:"
    echo -e "â€¢ Maintain persistent connection to C2 infrastructure"
    echo -e "â€¢ Report system status and infection confirmation"
    echo -e "â€¢ Receive commands and updates from attackers"
    echo -e "â€¢ Exfiltrate data in small, regular chunks\n"

    echo -e "${GREEN}Common Beacon Patterns${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${YELLOW}1. HTTP/HTTPS Beacons${NC}"
    echo -e "   â€¢ GET/POST requests to C2 servers"
    echo -e "   â€¢ Often disguised as legitimate web traffic"
    echo -e "   â€¢ May use common ports (80, 443) to avoid detection"
    echo -e "${YELLOW}2. DNS Beacons${NC}"
    echo -e "   â€¢ Use DNS queries to communicate with C2"
    echo -e "   â€¢ Data encoded in subdomain names"
    echo -e "   â€¢ Very stealthy, hard to detect and block"
    echo -e "${YELLOW}3. ICMP Beacons${NC}"
    echo -e "   â€¢ Use ping packets for communication"
    echo -e "   â€¢ Data hidden in ICMP payload"
    echo -e "   â€¢ Often allowed through firewalls"
    echo -e "${YELLOW}4. Encrypted Beacons${NC}"
    echo -e "   â€¢ Use encryption to hide communication content"
    echo -e "   â€¢ May use custom protocols or standard encryption"
    echo -e "   â€¢ Difficult to analyze without decryption keys\n"

    echo -e "${GREEN}Beacon Characteristics${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}Timing Patterns:${NC}"
    echo -e "â€¢ Fixed intervals (every 30s, 5min, 1hr)"
    echo -e "â€¢ Jittered intervals (random variation to avoid detection)"
    echo -e "â€¢ Sleep periods (long dormancy between active periods)"
    echo -e "${CYAN}Data Patterns:${NC}"
    echo -e "â€¢ System information (hostname, IP, OS version)"
    echo -e "â€¢ Status updates (alive, idle, active)"
    echo -e "â€¢ Encoded/encrypted payloads"
    echo -e "${CYAN}Network Patterns:${NC}"
    echo -e "â€¢ Regular connections to same destination"
    echo -e "â€¢ Consistent request sizes and formats"
    echo -e "â€¢ Predictable timing patterns\n"

    echo -e "${GREEN}Detection Techniques${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}1. Network Monitoring:${NC}"
    echo -e "   â€¢ Monitor for regular outbound connections"
    echo -e "   â€¢ Analyze connection timing patterns"
    echo -e "   â€¢ Look for connections to suspicious domains/IPs"
    echo -e "${CYAN}2. Traffic Analysis:${NC}"
    echo -e "   â€¢ Deep packet inspection (DPI)"
    echo -e "   â€¢ Protocol analysis and anomaly detection"
    echo -e "   â€¢ Payload analysis for encoded data"
    echo -e "${CYAN}3. Behavioral Analysis:${NC}"
    echo -e "   â€¢ Statistical analysis of network patterns"
    echo -e "   â€¢ Machine learning for anomaly detection"
    echo -e "   â€¢ Baseline comparison for unusual activity"
    echo -e "${CYAN}4. DNS Monitoring:${NC}"
    echo -e "   â€¢ Monitor DNS queries for suspicious patterns"
    echo -e "   â€¢ Analyze subdomain structures for encoded data"
    echo -e "   â€¢ Track queries to newly registered domains\n"

    echo -e "${GREEN}Prevention and Mitigation${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${GREEN}âœ“ Network Segmentation:${NC}"
    echo -e "  â€¢ Limit outbound connections from critical systems"
    echo -e "  â€¢ Use firewalls to block unauthorized communications"
    echo -e "${GREEN}âœ“ DNS Filtering:${NC}"
    echo -e "  â€¢ Block access to known malicious domains"
    echo -e "  â€¢ Monitor and filter DNS queries"
    echo -e "${GREEN}âœ“ Endpoint Detection:${NC}"
    echo -e "  â€¢ Deploy EDR solutions for behavioral monitoring"
    echo -e "  â€¢ Monitor process network activity"
    echo -e "${GREEN}âœ“ Traffic Inspection:${NC}"
    echo -e "  â€¢ Use DPI to analyze encrypted traffic metadata"
    echo -e "  â€¢ Implement SSL/TLS inspection where appropriate"
    echo -e "${GREEN}âœ“ Threat Intelligence:${NC}"
    echo -e "  â€¢ Use IOCs to identify known C2 infrastructure"
    echo -e "  â€¢ Monitor for beacon patterns in threat feeds\n"

    echo -e "${GREEN}Legal and Ethical Considerations${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${RED}âš  IMPORTANT:${NC} Only simulate beacons against systems you own or have permission"
    echo -e "${RED}âš  LEGAL:${NC} Unauthorized beacon simulation may violate computer crime laws"
    echo -e "${RED}âš  ETHICAL:${NC} Use simulations for defense improvement, not malicious purposes"
    echo -e "${RED}âš  PROFESSIONAL:${NC} Document findings and improve detection capabilities\n"
}

# Main interactive function
interactive_mode() {
    while true; do
        show_banner

        echo -e "${GREEN}Welcome to WetMonkey Malware Beacon Simulator!${NC}"
        echo -e "${YELLOW}This tool helps simulate and analyze malware beacon patterns for security testing.${NC}\n"
        echo -e "${RED}âš  WARNING: Only test against systems you own or have permission to test!${NC}\n"

        # Step 1: Simulation type selection
        echo -e "${GREEN}Step 1: Simulation Type${NC}"
        echo -e "Choose the type of beacon simulation:"
        echo -e "  ${YELLOW}1)${NC} Basic HTTP Beacon - Simple GET requests with timestamps"
        echo -e "  ${YELLOW}2)${NC} Encoded Beacon - Base64 encoded data transmission"
        echo -e "  ${YELLOW}3)${NC} JSON API Beacon - POST requests with JSON payloads"
        echo -e "  ${YELLOW}4)${NC} Steganographic Beacon - Hidden in fake image requests"
        echo -e "  ${YELLOW}5)${NC} DNS Beacon - DNS-based communication (simulated)"
        echo -e "  ${YELLOW}6)${NC} Educational Information - Learn about malware beacons"

        local simulation_type
        while true; do
            choice=$(simple_input "Select simulation type (1-6)")
            case "$choice" in
                "1") simulation_type="basic"; break ;;
                "2") simulation_type="encoded"; break ;;
                "3") simulation_type="json"; break ;;
                "4") simulation_type="steganography"; break ;;
                "5") simulation_type="dns"; break ;;
                "6") simulation_type="educational"; break ;;
                *) echo -e "${RED}Please select a number between 1-6${NC}" ;;
            esac
        done

        case "$simulation_type" in
            "educational")
                # Show educational information
                show_educational_info
                echo -e "\n${YELLOW}Press Enter to continue...${NC}"
                read -r
                ;;

            *)
                # Beacon simulation
                echo -e "\n${GREEN}Step 2: Target Configuration${NC}"

                local url
                while true; do
                    url=$(simple_input "Target URL (C2 server)")
                    if [ -z "$url" ]; then
                        echo -e "${RED}URL is required!${NC}"
                        continue
                    fi

                    if validate_url "$url"; then
                        break
                    else
                        echo -e "${RED}Please enter a valid URL (http:// or https://)${NC}"
                    fi
                done

                # Check connectivity
                check_url_reachable "$url"

                # Step 3: Beacon parameters
                echo -e "\n${GREEN}Step 3: Beacon Parameters${NC}"

                local interval
                while true; do
                    interval=$(simple_input "Beacon interval in seconds" "30")
                    if [[ $interval =~ ^[0-9]+$ ]] && [ $interval -ge 1 ] && [ $interval -le $MAX_INTERVAL ]; then
                        break
                    else
                        echo -e "${RED}Please enter a valid interval (1-${MAX_INTERVAL} seconds)${NC}"
                    fi
                done

                local count
                while true; do
                    count=$(simple_input "Number of beacons" "10")
                    if [[ $count =~ ^[0-9]+$ ]] && [ $count -ge 1 ] && [ $count -le $MAX_BEACONS ]; then
                        break
                    else
                        echo -e "${RED}Please enter a valid count (1-${MAX_BEACONS} beacons)${NC}"
                    fi
                done

                local jitter=0
                if ask_yes_no "Add timing jitter to avoid detection?" "y"; then
                    while true; do
                        jitter=$(simple_input "Jitter amount in seconds" "5")
                        if [[ $jitter =~ ^[0-9]+$ ]] && [ $jitter -ge 0 ] && [ $jitter -le $((interval / 2)) ]; then
                            break
                        else
                            echo -e "${RED}Please enter a valid jitter (0-$((interval / 2)) seconds)${NC}"
                        fi
                    done
                fi

                # Step 4: Confirmation and execution
                echo -e "\n${GREEN}Step 4: Simulation Summary${NC}"
                echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
                echo -e "${CYAN}Target: $url${NC}"
                echo -e "${CYAN}Pattern: $simulation_type${NC}"
                echo -e "${CYAN}Interval: ${interval}s (Â±${jitter}s jitter)${NC}"
                echo -e "${CYAN}Count: $count beacons${NC}"
                local estimated_time=$((interval * count))
                echo -e "${CYAN}Estimated duration: ${estimated_time}s (~$((estimated_time / 60))min)${NC}"
                echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

                echo -e "\n${RED}âš  WARNING: This will simulate malware beacon traffic!${NC}"
                echo -e "${RED}âš  Only proceed if you have authorization to test this target!${NC}"

                if ask_yes_no "Start beacon simulation?" "n"; then
                    echo -e "\n${CYAN}Starting beacon simulation...${NC}"

                    # Log start
                    log_json "malwarebeacon_start" "url=$url pattern=$simulation_type interval=$interval count=$count jitter=$jitter" 2>/dev/null || true

                    # Perform beacon simulation
                    simulate_beacon_traffic "$url" "$simulation_type" "$interval" "$count" "$jitter"

                    # Perform pattern analysis
                    analyze_beacon_patterns "$simulation_type" "$interval" "$count"

                    # Log end
                    log_json "malwarebeacon_end" "url=$url pattern=$simulation_type" 2>/dev/null || true
                else
                    echo -e "${YELLOW}Simulation cancelled.${NC}"
                fi
                ;;
        esac

        echo -e "\n${YELLOW}Press Enter to continue...${NC}"
        read -r

        if ! ask_yes_no "Perform another simulation?" "y"; then
            break
        fi
    done
}

# Legacy mode function
legacy_mode() {
    local url="$1"
    local interval="$2"
    local count="$3"

    echo -e "${YELLOW}Running in legacy mode...${NC}"
    echo -e "${RED}âš  WARNING: Only test URLs you own or have permission to test!${NC}\n"

    # Validate parameters
    if ! validate_url "$url"; then
        echo -e "${RED}Error: Invalid URL format${NC}" >&2
        exit 1
    fi

    if ! [[ $interval =~ ^[0-9]+$ ]] || [ $interval -lt 1 ] || [ $interval -gt $MAX_INTERVAL ]; then
        echo -e "${RED}Error: Invalid interval (1-${MAX_INTERVAL} seconds)${NC}" >&2
        exit 1
    fi

    if ! [[ $count =~ ^[0-9]+$ ]] || [ $count -lt 1 ] || [ $count -gt $MAX_BEACONS ]; then
        echo -e "${RED}Error: Invalid count (1-${MAX_BEACONS} beacons)${NC}" >&2
        exit 1
    fi

    # Log start
    log_json "malwarebeacon_start" "url=$url interval=$interval count=$count mode=legacy" 2>/dev/null || true

    # Perform basic beacon simulation
    echo -e "${CYAN}Starting legacy beacon simulation...${NC}"
    simulate_beacon_traffic "$url" "basic" "$interval" "$count" "0"

    # Log end
    log_json "malwarebeacon_end" "url=$url" 2>/dev/null || true
}

# Main function
main() {
    local url=""
    local interval="30"
    local count="10"
    local simulate_url=""

    # Parse command line arguments
    if [[ $# -gt 0 ]]; then
        while [[ $# -gt 0 ]]; do
            case "$1" in
                -h|--help)
                    show_help
                    exit 0
                    ;;
                -u|--url)
                    if [ -z "${2:-}" ]; then
                        echo -e "${RED}Error: -u requires a URL${NC}" >&2
                        exit 1
                    fi
                    url="$2"
                    shift 2
                    ;;
                --interval)
                    if [ -z "${2:-}" ]; then
                        echo -e "${RED}Error: --interval requires a number${NC}" >&2
                        exit 1
                    fi
                    interval="$2"
                    shift 2
                    ;;
                --count)
                    if [ -z "${2:-}" ]; then
                        echo -e "${RED}Error: --count requires a number${NC}" >&2
                        exit 1
                    fi
                    count="$2"
                    shift 2
                    ;;
                --simulate)
                    if [ -z "${2:-}" ]; then
                        echo -e "${RED}Error: --simulate requires a URL${NC}" >&2
                        exit 1
                    fi
                    simulate_url="$2"
                    shift 2
                    ;;
                *)
                    echo -e "${RED}Unknown option: $1${NC}" >&2
                    echo "Use -h for help." >&2
                    exit 1
                    ;;
            esac
        done

        # Handle quick simulation mode
        if [ -n "$simulate_url" ]; then
            echo -e "${GREEN}Quick Beacon Simulation: $simulate_url${NC}"

            if ! validate_url "$simulate_url"; then
                echo -e "${RED}Error: Invalid URL format${NC}" >&2
                exit 1
            fi

            # Log start
            log_json "malwarebeacon_start" "url=$simulate_url mode=quick" 2>/dev/null || true

            # Perform quick simulation with default parameters
            simulate_beacon_traffic "$simulate_url" "basic" "30" "5" "0"
            analyze_beacon_patterns "basic" "30" "5"

            # Log end
            log_json "malwarebeacon_end" "url=$simulate_url" 2>/dev/null || true

            exit 0
        fi

        # Handle legacy mode
        if [ -n "$url" ]; then
            legacy_mode "$url" "$interval" "$count"
            exit $?
        fi

        # If we get here, invalid combination of arguments
        echo -e "${RED}Error: Invalid argument combination${NC}" >&2
        echo "Use -h for help or run without arguments for interactive mode." >&2
        exit 1
    fi

    # Check dependencies for interactive mode
    missing_deps=()
    if ! command -v curl &> /dev/null; then
        missing_deps+=("curl")
    fi

    if [ ${#missing_deps[@]} -gt 0 ]; then
        echo -e "${YELLOW}Warning: Some tools are missing: ${missing_deps[*]}${NC}"
        echo -e "${YELLOW}Beacon simulation requires curl.${NC}\n"
        exit 1
    fi

    # Start interactive mode
    interactive_mode
}

# Run the main function with all arguments
main "$@"
